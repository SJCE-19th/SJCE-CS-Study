## 0. 동시성 제어란 무엇인가?

여러 트랜잭션에서, db의 정합성을 보장하는 것.

→ 자바에서의 동시성 제어란 무엇일까요? 스레드!

데이터베이스에서는 Lock, MVCC를  활용하여 동시성 제어를 진행한다.

## 1. Lock

### 1.1. 공유 락, Shared-Lock, S-Lock

- 특정 데이터에 접근할 때, **읽는 동안** 값이 변경이 되면 안될 때 락을 건다.
- 다른 트랜잭션이 Read 작업 가능함

### 1.2. 배타 락, Exclusive-Lock, X-Lock

- 특정 데이터에 **읽기 작업과 쓰기 작업** 모두 락을 건다.
- 다른 트랜잭션이 Read, Write 작업 모두 불가능
    - Locking read가 안되는 것이지, 일반 `SELECT`는 가능함!!!

### 1.3. 락의 범위 in Oracle

1. Row-level lock
    - Oracle에서는 Record에 S Lock을 거는 것은 불가능하다. 대신 Record에 X Lock은 가능하다.
        
        ```sql
        -- Oracle
        SELECT *
        FROM account
        WHERE id = 1
        FOR UPDATE;
        
        ```
        
2. Table Lock
    - 특정 테이블에 거는 락
        
        ```sql
        LOCK TABLE account IN [SHARE MODE];
        ```
        
        - SHARE MODE
        - EXCLUSIVE MODE
        - ROW EXCLUSIVE MORE
3. Gap Lock
    - Mysql에만 있는 락.
    - 레코드 한정으로 거는게 아니라, 앞뒤 인덱스 공간에도 락을 걸어 범위조회나 범위 insert/delete도 막음
    

### 1.4.락킹으로 발생할 수 있는 문제점

- 블로킹
    - 하나의 트랜잭션이, 다른 락을 기다리는 상태
    - 블로킹이 많아지면 성능저하
- 데드락
    
    <img width="1141" height="587" alt="image" src="https://github.com/user-attachments/assets/38e7edd7-1cf9-4d77-adde-e99e9bd9c08f" />

    
    - 두 개 이상의 트랜잭션이 서로의 락을 기다리는 상태
    - 데드락 발생시, 각 DBMS에서 detect 하여 해결한다.
        
        
        | DBMS | 데드락 감지 방식 | 처리 방식 | 에러 메시지 예시 |
        | --- | --- | --- | --- |
        | **MySQL (InnoDB)** | 실시간 Wait-For Graph 감지 | 대기 시간 짧은 쪽 롤백 | `ERROR 1213 (40001): Deadlock found...` |
        | **PostgreSQL** | 락 대기 시 그래프 검사 | 무작위 or 비용 작은 쪽 롤백 | `ERROR: deadlock detected` |
        | **Oracle** | 락 대기 중 타임아웃 없이 즉시 감지 | 비용 적은 쪽 롤백 | `ORA-00060: deadlock detected` |
        | **SQL Server** | 주기적으로 검사 | “비용”이 가장 작은 트랜잭션 롤백 | `Transaction (Process ID ...) was deadlocked...` |
- 동시성 제어에서 **Lock**만을 사용하면 너무 복잡하고 문제가 있어서 MVCC가 도입되게 되었다.

## 2. MVCC

- X-Lock에서 Locking read가 안되는 것이지, 일반 `SELECT`는 가능함!!!는 **MVCC**가 있기 때문에 가능한 것
    - MVCC가 과거의 데이터인 스냅샷을 보여줌
- MVCC(Multi Version Concurreny Control)가 뭐냐? 간단히 말해, 트랜잭션 시작 전의 **원본 데이터(snapshot, UNDO 영역)**와 **변경 데이터**를 둘 다 가지고 있는 방식
- 데이터 변경중 타 트랜잭션에서 데이터에 접근하려고 할 때, **스냅샷**의 데이터를 읽게 하는 방법
    - 데이터 변경이 반영되었을 경우 변경 데이터를 원본 데이터에 반영
    - 데이터 변경이 롤백되었을 경우 스냅샷을 기반으로 데이터 복원

## 

### WAL

- Write-Ahead Logging
- 동시성 제어 기법이 아니라, **데이터를 변경하기 전 로그를 먼저 쓰는 장애복구 기법**
- 이 로그를 작성하는 곳이 **REDO 영역**

### REDO

- REDO 는 **했던 작업의 모든 내용**이 담겨져 있다.
- 과거의 특정 시점에서 **현재의 특정 시점으로 데이터를 복구할 수 있다. (roll-forward라 부름)**
- 특정 작업이 진행중 비정상적으로 종료되었을 때(시스템 장애) 사용 가능

### UNDO

- UNDO는 **작업이 진행될때 변경 전의 데이터를 모두 저장한다.**
- 현재 시점에서 **과거의 특정 시점으로 데이터를 복구할 수 있다. (roll-back)**
- 트랜잭션 진행 중 문제가 발생하여 최종 커밋으로 롤백할 때 사용

### 낙관락 vs 비관락

- 비관락은, **데이터 충돌이 발생할 것이라 가정하고 미리 락을 거는 것**
    - 충돌이 없고 안전하지만 성능이 저하되고, 데드락이 발생 가능하다
    
    ```sql
    SELECT * FROM orders WHERE id=10 FOR UPDATE;  -- 행 X락
    ```
    
- 낙관락은, 충돌이 발생할 것을 가정하지 않는 방법.
    - 대신 업데이트 이후 버전컬럼 또는 타임스탬프를비교하여 실제로 충돌이 발생하지 않았는지 체크
        
         
        
        ```sql
        UPDATE orders
           SET qty=qty-1, version=version+1
         WHERE id=10 AND version=:old_version;
        ```
