
# PostgreSQL에서의 동시성 제어 방법


PostgreSQL에서는 MVCC로 동시성 제어를 지원합니다. 이를 어떤 식으로 지원하는지 알아봅시다.


## 1. MVCC란?

### 1.1 정의와 목적
MVCC(Multi-Version Concurrency Control)는 PostgreSQL이 동시성 제어를 위해 사용하는 핵심 메커니즘입니다. 이는 데이터베이스의 동일한 데이터에 여러 트랜잭션이 동시에 접근할 때 일관성을 보장하면서도 높은 동시성을 제공하는 기술입니다.

전통적인 데이터베이스 시스템이 Lock을 사용하여 동시성을 제어하는 것과 달리, MVCC는 **데이터의 여러 버전을 동시에 유지**함으로써 읽기와 쓰기 작업이 서로를 방해하지 않도록 합니다. 이는 마치 Git이 파일의 여러 버전을 관리하는 것과 유사한 개념입니다.

### 1.2 핵심 원칙: "Readers don't block writers, writers don't block readers"

이 원칙은 MVCC의 가장 중요한 특징을 한 문장으로 표현한 것입니다:

- **읽기 작업(SELECT)**은 쓰기 작업(INSERT/UPDATE/DELETE)을 차단하지 않습니다
  - 누군가 데이터를 읽고 있어도, 다른 사용자는 동시에 그 데이터를 수정할 수 있습니다
  
- **쓰기 작업**은 읽기 작업을 차단하지 않습니다
  - 데이터가 수정되고 있는 중에도, 다른 사용자는 해당 데이터의 이전 버전을 읽을 수 있습니다
  
- 오직 **쓰기-쓰기 충돌**만 차단이 발생합니다
  - 두 트랜잭션이 동시에 같은 row를 수정하려 할 때만 하나가 대기해야 합니다

### 1.3 왜 MVCC가 필요한가?

대규모 동시 접속 환경에서 전통적인 Lock 기반 시스템은 심각한 성능 저하를 겪습니다. 예를 들어, 온라인 쇼핑몰에서 수천 명이 동시에 상품 정보를 조회하고 주문하는 상황을 생각해보세요. Lock 기반 시스템에서는 한 사용자가 상품 정보를 조회하는 동안 다른 사용자들이 대기해야 하지만, MVCC에서는 모든 사용자가 동시에 작업할 수 있습니다.

## 2. MVCC의 작동 원리

### 2.1 다중 버전 관리

PostgreSQL은 데이터를 수정할 때 기존 데이터를 즉시 삭제하지 않고, **새로운 버전을 생성**합니다. 이렇게 하면 각 트랜잭션이 자신에게 적합한 버전을 볼 수 있게 됩니다.

#### 버전 생성 과정 상세 설명:

```sql
-- 테이블 생성 및 초기 데이터 삽입
CREATE TABLE accounts (
    id INTEGER PRIMARY KEY,
    balance NUMERIC
);

-- 1. 초기 INSERT (Transaction ID = 100)
INSERT INTO accounts (id, balance) VALUES (1, 1000);
```

이 시점에서 데이터베이스 내부적으로는 다음과 같은 tuple이 생성됩니다:
- **물리적 위치(ctid)**: (0,1) - 0번 페이지의 1번 항목
- **xmin**: 100 (이 tuple을 생성한 트랜잭션 ID)
- **xmax**: 0 (아직 삭제/수정되지 않았음을 의미)
- **실제 데이터**: id=1, balance=1000

```sql
-- 2. UPDATE 수행 (Transaction ID = 200)
BEGIN;
UPDATE accounts SET balance = 1500 WHERE id = 1;
COMMIT;
```

UPDATE가 실행되면 PostgreSQL은:
1. 기존 tuple을 그대로 두고 xmax를 200으로 설정 (이 버전이 Transaction 200에 의해 "무효화"되었음을 표시)
2. 새로운 tuple을 생성

결과적으로 두 개의 버전이 존재하게 됩니다:

**이전 버전 (Dead Tuple)**:
- ctid: (0,1)
- xmin: 100 (Transaction 100이 생성)
- xmax: 200 (Transaction 200이 무효화)
- 데이터: id=1, balance=1000

**새 버전 (Live Tuple)**:
- ctid: (0,2)
- xmin: 200 (Transaction 200이 생성)
- xmax: 0 (아직 유효함)
- 데이터: id=1, balance=1500

#### 왜 이렇게 복잡하게 관리하는가?

이 시점에서 Transaction 150이 실행 중이었다면:
- Transaction 150은 Transaction 200의 변경을 보지 못해야 합니다 (격리성)
- 따라서 Transaction 150은 여전히 balance=1000인 이전 버전을 봅니다
- Transaction 201은 balance=1500인 새 버전을 봅니다

이것이 바로 "Multi-Version"의 의미입니다.

### 2.2 버전 가시성 결정

각 트랜잭션은 시작할 때 "스냅샷(Snapshot)"을 생성합니다. 스냅샷은 "이 시점에 어떤 트랜잭션들이 완료되었고, 어떤 것들이 진행 중인지"에 대한 정보입니다.

#### 스냅샷의 구성 요소:
```c
typedef struct SnapshotData {
    TransactionId xmin;      // 가장 오래된 활성 XID
    TransactionId xmax;      // 가장 최근 완료된 XID + 1
    TransactionId *xip;      // 활성 트랜잭션 ID 배열
    uint32 xcnt;            // 활성 트랜잭션 수
    // ... 기타 필드
} SnapshotData;
```

- **xmin**: 아직 실행 중인 가장 오래된 트랜잭션 ID
- **xmax**: 다음에 할당될 트랜잭션 ID
- **xip[]**: 현재 실행 중인 트랜잭션 ID 목록

#### 실제 동작 예시:

```sql
-- 현재 상황: accounts 테이블에 id=1, balance=1500인 row가 있음
-- (xmin=200, xmax=0으로 저장되어 있음)

-- Session A: Transaction 300 시작
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- 이 시점의 스냅샷 생성: {xmin=300, xmax=302, xip=[301]}
-- (Transaction 301이 실행 중이라고 가정)

SELECT * FROM accounts WHERE id = 1;
-- 결과: balance = 1500
-- 이유: xmin(200) < snapshot.xmin(300)이고 커밋되었으므로 보임
```

```sql
-- Session B: Transaction 301이 동시에 실행
BEGIN;
UPDATE accounts SET balance = 2000 WHERE id = 1;
-- 기존 tuple의 xmax를 301로 설정
-- 새 tuple 생성: xmin=301, xmax=0, balance=2000
COMMIT;
```

```sql
-- Session A: 다시 조회
SELECT * FROM accounts WHERE id = 1;
-- 결과: 여전히 balance = 1500
-- 이유: Transaction 301은 Session A의 스냅샷에서 "실행 중"으로 기록되어 있으므로
--      Transaction 301이 만든 새 버전은 보이지 않음
```

#### 가시성 규칙의 핵심:

트랜잭션이 특정 tuple을 볼 수 있는지 판단하는 과정:

1. **tuple의 xmin (생성자) 확인**:
   - xmin이 내 스냅샷의 xmin보다 크면? → 너무 새로운 데이터, 안 보임
   - xmin이 실행 중인 트랜잭션 목록(xip)에 있으면? → 아직 커밋 안 됨, 안 보임
   - xmin이 커밋되었고 내 스냅샷 범위 내면? → 보임

2. **tuple의 xmax (삭제자) 확인**:
   - xmax가 0이면? → 아직 삭제 안 됨, 보임
   - xmax가 내 스냅샷의 xmax보다 크면? → 내가 시작한 후 삭제됨, 여전히 보임
   - xmax가 실행 중인 트랜잭션이면? → 삭제 진행 중, 여전히 보임
   - xmax가 커밋되었고 내 스냅샷 범위 내면? → 삭제됨, 안 보임

## 3. MVCC vs 전통적인 Lock 기반 동시성 제어

### 3.1 전통적인 2PL (Two-Phase Locking)

전통적인 데이터베이스 시스템(예: 초기 MySQL InnoDB, Oracle의 일부 모드)은 2PL(Two-Phase Locking)을 사용합니다:

```sql
-- 전통적인 Lock 기반 시스템에서의 동작
-- Transaction A: 오후 2시에 시작
BEGIN;
SELECT * FROM accounts WHERE id = 1;  
-- Shared Lock(S-Lock) 획득
-- 다른 트랜잭션의 읽기는 허용, 쓰기는 차단

-- Transaction B: 오후 2시 1초에 시작
BEGIN;
UPDATE accounts SET balance = 2000 WHERE id = 1;  
-- Exclusive Lock(X-Lock) 필요
-- 하지만 Transaction A가 S-Lock을 가지고 있음
-- 결과: Transaction B는 대기! (WAITING...)
-- Transaction A가 끝날 때까지 아무것도 할 수 없음

-- Transaction A: 오후 2시 30초 (긴 처리 후)
COMMIT;  -- Lock 해제

-- Transaction B: 이제야 진행 가능
-- 30초 동안 대기했음!
```

**문제점**:
- 읽기 작업이 쓰기를 차단 → 동시성 저하
- 긴 읽기 트랜잭션이 있으면 쓰기가 오래 대기
- Lock 경합으로 인한 Deadlock 위험 증가

### 3.2 PostgreSQL의 MVCC

PostgreSQL의 MVCC는 완전히 다른 접근을 사용합니다:

```sql
-- PostgreSQL MVCC에서의 동작
-- Transaction A: 오후 2시에 시작
BEGIN;
SELECT * FROM accounts WHERE id = 1;  
-- Lock 없음! 단지 현재 버전을 읽음
-- balance = 1000 (xmin=100, xmax=0인 버전)

-- Transaction B: 오후 2시 1초에 시작
BEGIN;
UPDATE accounts SET balance = 2000 WHERE id = 1;  
-- 대기하지 않음! 즉시 실행
-- 기존 버전은 그대로 두고 새 버전 생성
-- 이전 버전: xmin=100, xmax=301 (무효화 표시)
-- 새 버전: xmin=301, xmax=0, balance=2000
COMMIT;

-- Transaction A: 계속 읽기 가능
SELECT * FROM accounts WHERE id = 1;
-- 여전히 balance = 1000을 봄
-- (자신의 스냅샷에 맞는 버전을 봄)
COMMIT;
```

**장점**:
- Transaction B가 전혀 대기하지 않음
- 두 트랜잭션이 서로 방해하지 않고 동시 실행
- Deadlock 가능성 크게 감소


## 4. MVCC의 장단점

### 4.1 장점

#### 1. **높은 동시성 (High Concurrency)**
읽기와 쓰기가 서로를 차단하지 않아 많은 사용자가 동시에 작업할 수 있습니다. 예를 들어, 한 사용자가 월별 매출 리포트를 생성하는 동안(긴 읽기 작업) 다른 사용자들은 자유롭게 주문을 입력(쓰기 작업)할 수 있습니다.

#### 2. **일관된 읽기 (Consistent Read)**
트랜잭션이 시작된 시점의 일관된 데이터베이스 상태를 봅니다. 리포트 생성 중에 다른 트랜잭션이 데이터를 변경해도, 리포트는 시작 시점의 데이터를 기준으로 일관되게 생성됩니다.

#### 3. **Deadlock 감소**
Lock 경합이 줄어들어 교착 상태가 발생할 가능성이 크게 감소합니다. 주로 쓰기-쓰기 충돌에서만 Lock이 발생하므로, 복잡한 Lock 체인이 형성되기 어렵습니다.

#### 4. **읽기 성능 향상**
SELECT 쿼리가 Lock을 기다리지 않으므로 응답 시간이 예측 가능하고 빠릅니다. 특히 읽기가 많은 워크로드에서 큰 성능 이점을 제공합니다.

### 4.2 단점과 대응 방안

#### 1. **공간 오버헤드 (Space Overhead)**

**문제**: 동일한 row의 여러 버전을 유지하므로 저장 공간이 더 필요합니다.

```sql
-- 예: 1개 row를 100번 UPDATE하면
-- Lock 기반: 1개 row만 존재
-- MVCC: 최대 101개 버전 존재 (원본 + 100개 수정 버전)

-- 실제 공간 사용량 확인
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY n_dead_tup DESC;
```

**대응**: 적절한 AUTOVACUUM 설정으로 dead tuple을 주기적으로 정리

#### 2. **VACUUM 필요성**

**문제**: 오래된 버전(dead tuple)을 정리하는 VACUUM 작업이 필요합니다.

```sql
-- Dead tuple이 쌓이면 성능 저하
-- 테이블 크기: 1GB
-- Live tuples: 100,000
-- Dead tuples: 900,000
-- 실제 필요한 공간의 10배를 사용!

-- VACUUM 실행
VACUUM ANALYZE tablename;

-- 자동 VACUUM 설정 확인
SHOW autovacuum;
SHOW autovacuum_vacuum_scale_factor;  -- 기본 0.2 (20%)
```

**대응**: 워크로드에 맞는 AUTOVACUUM 파라미터 튜닝

#### 3. **Transaction ID Wraparound**

**문제**: 32-bit 트랜잭션 ID는 약 40억 개 후 순환됩니다.

```sql
-- XID 나이 확인
SELECT 
    datname,
    age(datfrozenxid) as xid_age,
    2^31 - age(datfrozenxid) as xids_until_wraparound
FROM pg_database;

-- 위험: xid_age가 20억에 근접하면 경고
-- VACUUM FREEZE로 해결
```

**대응**: 정기적인 VACUUM FREEZE와 모니터링

#### 4. **HOT Update 제약**

**문제**: 인덱스가 있는 컬럼을 UPDATE하면 모든 인덱스를 업데이트해야 합니다.

```sql
-- 인덱스 컬럼 UPDATE (비효율적)
UPDATE users SET email = 'new@email.com' WHERE id = 1;
-- email에 인덱스가 있다면, 인덱스도 새 버전 생성

-- 비인덱스 컬럼 UPDATE (HOT Update, 효율적)
UPDATE users SET last_login = NOW() WHERE id = 1;
-- 인덱스 업데이트 불필요, 같은 페이지 내에서 처리
```

**대응**: 
- 자주 UPDATE되는 컬럼은 인덱스 생성 신중히 고려
- Fill Factor 조정으로 HOT Update 가능성 증가

## 5. MVCC 구현 세부사항

### 5.1 Tuple Header 구조

PostgreSQL의 모든 row(tuple)는 실제 데이터 외에 MVCC를 위한 메타데이터를 포함합니다. 이 메타데이터는 약 23바이트의 오버헤드를 차지합니다:

```c
typedef struct HeapTupleHeaderData {
    TransactionId xmin;      // 이 tuple을 생성한 트랜잭션 ID (4 bytes)
    TransactionId xmax;      // 이 tuple을 삭제/업데이트한 트랜잭션 ID (4 bytes)
    CommandId cmin;          // 삽입 명령 ID (4 bytes)
    CommandId cmax;          // 삭제 명령 ID (4 bytes)
    ItemPointerData ctid;    // 현재 또는 새 버전의 tuple 위치 (6 bytes)
    uint16 t_infomask;       // 다양한 플래그 비트 (2 bytes)
    uint16 t_infomask2;      // 추가 플래그 비트 (2 bytes)
    uint8 t_hoff;           // 헤더 오프셋 (1 byte)
} HeapTupleHeaderData;
```

#### 각 필드의 역할:

- **xmin**: 이 tuple을 만든 트랜잭션의 ID입니다. tuple이 언제 "태어났는지"를 나타냅니다.
- **xmax**: 이 tuple을 삭제하거나 새 버전으로 대체한 트랜잭션의 ID입니다. 0이면 아직 살아있음을 의미합니다.
- **cmin/cmax**: 같은 트랜잭션 내에서 여러 명령을 구분하기 위한 ID입니다.
- **ctid**: tuple의 물리적 위치 (page_number, item_index) 또는 UPDATE 시 새 버전의 위치를 가리킵니다.
- **t_infomask**: COMMITTED, ABORTED, LOCKED 등의 상태 정보를 비트 플래그로 저장합니다.

### 5.2 가시성 판단 알고리즘

PostgreSQL이 특정 tuple이 현재 트랜잭션에게 보이는지 판단하는 실제 과정을 단계별로 설명하겠습니다.
아래 코드는 과정을 표현하기 위해 python으로 단순화 하였습니다.

```python
def is_tuple_visible(tuple, snapshot):
    """
    tuple이 현재 트랜잭션의 snapshot에서 보이는지 판단
    
    Args:
        tuple: 확인할 tuple (xmin, xmax 정보 포함)
        snapshot: 현재 트랜잭션의 스냅샷 (xmin, xmax, xip 포함)
    
    Returns:
        bool: tuple이 보이면 True, 안 보이면 False
    """
    
    # Step 1: tuple을 생성한 트랜잭션(xmin) 검증
    if tuple.xmin == my_transaction_id:
        # 내가 만든 tuple은 항상 보임
        return not is_deleted_by_me(tuple)
    
    if not is_committed(tuple.xmin):
        # 생성 트랜잭션이 아직 커밋 안 됨 or 롤백됨
        return False
    
    if tuple.xmin >= snapshot.xmax:
        # tuple이 내 스냅샷 이후에 생성됨
        return False
        
    if tuple.xmin in snapshot.xip:
        # 생성 트랜잭션이 내 스냅샷 시점에 실행 중이었음
        return False
    
    # Step 2: tuple을 삭제한 트랜잭션(xmax) 검증
    if tuple.xmax == 0:
        # 아직 삭제되지 않음
        return True
        
    if tuple.xmax == my_transaction_id:
        # 내가 삭제한 tuple은 안 보임
        return False
        
    if not is_committed(tuple.xmax):
        # 삭제 트랜잭션이 커밋 안 됨 or 롤백됨
        # tuple은 여전히 유효
        return True
        
    if tuple.xmax >= snapshot.xmax:
        # 내 스냅샷 이후에 삭제됨
        # 나에게는 여전히 보임
        return True
        
    if tuple.xmax in snapshot.xip:
        # 삭제 트랜잭션이 내 스냅샷 시점에 실행 중
        # 나에게는 여전히 보임
        return True
    
    # tuple이 내 스냅샷 이전에 삭제됨
    return False
```

#### 실제 예시로 이해하기:

```sql
-- 시간 순서대로 발생하는 이벤트
-- T=1: Transaction 100이 row 생성
INSERT INTO test VALUES (1, 'A');  -- xmin=100, xmax=0

-- T=2: Transaction 150 시작 (스냅샷 생성)
BEGIN;  -- snapshot: {xmin=150, xmax=200, xip=[151, 152]}

-- T=3: Transaction 151이 row 수정
UPDATE test SET value='B' WHERE id=1;
-- 이전 버전: xmin=100, xmax=151
-- 새 버전: xmin=151, xmax=0

-- T=4: Transaction 150이 조회
SELECT * FROM test WHERE id=1;
-- 결과: value='A' 
-- 이유: xmax(151)가 xip에 있음 (실행 중) → 이전 버전 보임
```

## 6. 실제 예제: MVCC 동작 관찰

### 6.1 테스트 환경 설정

실제로 MVCC가 어떻게 동작하는지 직접 확인해보겠습니다:

```sql
-- 테스트 테이블 생성
CREATE TABLE mvcc_test (
    id INTEGER PRIMARY KEY,
    value TEXT,
    version INTEGER DEFAULT 1
);

-- 초기 데이터 삽입
INSERT INTO mvcc_test (id, value) VALUES (1, 'initial');
INSERT INTO mvcc_test (id, value) VALUES (2, 'second');
INSERT INTO mvcc_test (id, value) VALUES (3, 'third');

-- 현재 트랜잭션 ID 확인
SELECT txid_current();  -- 예: 1000
```

### 6.2 숨겨진 시스템 컬럼 확인

PostgreSQL은 일반적으로 숨겨진 시스템 컬럼들을 가지고 있습니다. 이들을 직접 조회해보면 MVCC의 동작을 이해할 수 있습니다:

```sql
-- 시스템 컬럼 조회
SELECT 
    ctid,      -- tuple의 물리적 위치 (page, item)
    xmin,      -- 생성 트랜잭션 ID
    xmax,      -- 삭제/업데이트 트랜잭션 ID
    id,
    value
FROM mvcc_test;

-- 결과:
-- ctid  | xmin | xmax | id | value
-- (0,1) | 1000 | 0    | 1  | initial
-- (0,2) | 1000 | 0    | 2  | second
-- (0,3) | 1000 | 0    | 3  | third
```

**해석**:
- ctid (0,1): 0번 페이지의 1번 아이템
- xmin 1000: Transaction 1000이 이 tuple을 생성
- xmax 0: 아직 삭제/수정되지 않음

### 6.3 UPDATE와 버전 생성 관찰

이제 UPDATE가 실제로 어떻게 새 버전을 만드는지 관찰해봅시다:

```sql
-- Session 1: UPDATE 실행
BEGIN;
SELECT txid_current();  -- 예: 1001
UPDATE mvcc_test SET value = 'updated', version = 2 WHERE id = 1;

-- 같은 세션에서 시스템 컬럼 확인
SELECT ctid, xmin, xmax, * FROM mvcc_test WHERE id = 1;
-- ctid  | xmin | xmax | id | value   | version
-- (0,4) | 1001 | 0    | 1  | updated | 2
-- 새로운 ctid (0,4)에 새 버전이 생성됨!
```

```sql
-- Session 2: 다른 연결에서 동시에 조회
SELECT ctid, xmin, xmax, * FROM mvcc_test WHERE id = 1;
-- ctid  | xmin | xmax | id | value   | version
-- (0,1) | 1000 | 1001 | 1  | initial | 1
-- 여전히 이전 버전을 봄 (xmax=1001은 진행 중인 트랜잭션)
```

```sql
-- Session 1: COMMIT
COMMIT;

-- Session 2: 다시 조회
SELECT ctid, xmin, xmax, * FROM mvcc_test WHERE id = 1;
-- ctid  | xmin | xmax | id | value   | version
-- (0,4) | 1001 | 0    | 1  | updated | 2
-- 이제 새 버전을 봄
```

### 6.4 동시 트랜잭션 시뮬레이션

여러 트랜잭션이 동시에 실행될 때 각자 어떤 버전을 보는지 확인:

```sql
-- 준비: 현재 상태 확인
SELECT ctid, xmin, xmax, * FROM mvcc_test;

-- Session A: Repeatable Read 트랜잭션 시작
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT txid_current();  -- 예: 1100
-- 스냅샷 생성됨
SELECT * FROM mvcc_test WHERE id = 1;
-- value = 'updated', version = 2
```

```sql
-- Session B: 동시에 데이터 수정
BEGIN;
SELECT txid_current();  -- 예: 1101
UPDATE mvcc_test SET value = 'changed by B', version = 3 WHERE id = 1;
COMMIT;
-- 새 버전 생성 완료
```

```sql
-- Session C: 새로운 읽기 전용 트랜잭션
BEGIN;
SELECT * FROM mvcc_test WHERE id = 1;
-- value = 'changed by B', version = 3
-- Session C는 최신 커밋된 버전을 봄
COMMIT;
```

```sql
-- Session A: 여전히 처음 본 버전 유지
SELECT * FROM mvcc_test WHERE id = 1;
-- value = 'updated', version = 2
-- Repeatable Read이므로 스냅샷이 유지됨!

-- 시스템 컬럼으로 확인
SELECT ctid, xmin, xmax, * FROM mvcc_test WHERE id = 1;
-- 자신의 스냅샷에 맞는 버전을 봄
COMMIT;
```

### 6.5 DELETE와 버전 관리

DELETE도 실제로는 즉시 삭제하지 않고 표시만 합니다:

```sql
-- DELETE 동작 관찰
BEGIN;
SELECT txid_current();  -- 예: 1200
DELETE FROM mvcc_test WHERE id = 2;

-- 같은 트랜잭션에서는 안 보임
SELECT * FROM mvcc_test WHERE id = 2;
-- 0 rows

-- 하지만 시스템 레벨에서는 여전히 존재
SELECT ctid, xmin, xmax, * FROM mvcc_test WHERE id = 2;
-- ERROR: 일반 SELECT로는 안 보임

-- 다른 세션에서는 여전히 보임
-- Session 2:
SELECT * FROM mvcc_test WHERE id = 2;
-- id | value  | version
-- 2  | second | 1

COMMIT;
```

## 7. MVCC와 Isolation Level의 관계

PostgreSQL의 각 Isolation Level은 MVCC를 다르게 활용합니다. 같은 MVCC 메커니즘을 사용하지만, 스냅샷을 생성하는 시점과 충돌 처리 방식이 다릅니다:

### 7.1 Read Committed (기본값)

**특징**: 각 SQL문마다 새로운 스냅샷을 생성합니다.

```sql
-- Read Committed 동작 예시
BEGIN; -- 기본값이 Read Committed

-- 시점 1: 첫 번째 SELECT
SELECT * FROM accounts WHERE id = 1;  -- balance = 1000
-- 스냅샷 A 생성 및 사용

-- 다른 트랜잭션이 UPDATE하고 COMMIT
-- UPDATE accounts SET balance = 2000 WHERE id = 1;

-- 시점 2: 두 번째 SELECT
SELECT * FROM accounts WHERE id = 1;  -- balance = 2000
-- 새로운 스냅샷 B 생성 - 커밋된 변경사항 반영!

COMMIT;
```

**장점**: 최신 커밋된 데이터를 볼 수 있음
**단점**: Non-repeatable read 발생 가능

### 7.2 Repeatable Read

**특징**: 트랜잭션 시작 시 하나의 스냅샷을 생성하고 끝까지 유지합니다.

```sql
-- Repeatable Read 동작 예시
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- 이 시점에 스냅샷 생성

-- 시점 1: 첫 번째 SELECT
SELECT * FROM accounts WHERE id = 1;  -- balance = 1000

-- 다른 트랜잭션이 UPDATE하고 COMMIT
-- UPDATE accounts SET balance = 2000 WHERE id = 1;

-- 시점 2: 두 번째 SELECT
SELECT * FROM accounts WHERE id = 1;  -- 여전히 balance = 1000
-- 동일한 스냅샷 사용 - 일관된 읽기!

-- UPDATE 시도 시
UPDATE accounts SET balance = 1500 WHERE id = 1;
-- ERROR: could not serialize access due to concurrent update
-- 다른 트랜잭션이 먼저 수정했으므로 충돌!

COMMIT;
```

**장점**: 트랜잭션 내에서 일관된 데이터 뷰
**단점**: UPDATE 충돌 시 재시도 필요

### 7.3 Serializable

**특징**: Repeatable Read + SSI(Serializable Snapshot Isolation)로 추가 충돌 감지

```sql
-- Serializable에서만 감지되는 Write Skew 예시
-- 두 의사가 동시에 당직을 취소하려는 상황

-- Session A
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(*) FROM doctors WHERE on_call = true;  -- 2명
-- 충분하니 나는 빠져도 됨
UPDATE doctors SET on_call = false WHERE id = 1;

-- Session B (동시에)
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(*) FROM doctors WHERE on_call = true;  -- 2명
-- 충분하니 나는 빠져도 됨
UPDATE doctors SET on_call = false WHERE id = 2;

-- Session A
COMMIT;  -- 성공

-- Session B
COMMIT;  -- ERROR: could not serialize access
-- SSI가 dangerous structure 감지!
```

**장점**: True serializability 보장
**단점**: 약간의 성능 오버헤드 (predicate lock 관리)

## 8. 핵심 개념 정리

### MVCC 동작 흐름 요약

```
1. INSERT: 새 tuple 생성 (xmin=현재XID, xmax=0)
   ↓
2. UPDATE: 기존 tuple의 xmax=현재XID 설정 + 새 tuple 생성
   ↓
3. DELETE: 기존 tuple의 xmax=현재XID 설정
   ↓
4. SELECT: 스냅샷과 tuple의 xmin/xmax 비교하여 가시성 결정
   ↓
5. VACUUM: 더 이상 필요없는 dead tuple 제거
```

### MVCC의 핵심 이점

1. **동시성**: 수천 명이 동시에 같은 데이터를 읽고 쓸 수 있음
2. **일관성**: 각 트랜잭션은 일관된 데이터베이스 상태를 봄
3. **격리성**: 다른 트랜잭션의 미완료 작업이 보이지 않음
4. **성능**: Lock 대기 시간이 거의 없어 예측 가능한 응답 시간

#### 버전 관리의 핵심: xmin과 xmax

- **xmin**: tuple의 "생일" - 언제 태어났는가?
- **xmax**: tuple의 "사망시각" - 언제 죽었는가? (0이면 아직 살아있음)
- 모든 가시성 판단은 이 두 값과 스냅샷의 비교로 이루어집니다.
