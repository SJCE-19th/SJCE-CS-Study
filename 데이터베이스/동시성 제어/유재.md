## 개요

- DMBS는 여러 트랜잭션이 동시에 실행될 떄 발생할 수 있는 문제를 방지하기 위해 동시성 제어라는 기술을 사용

```
동시성 이슈로 발생할 수 있는 문제
- Dirty Read: 커밋되지 않은 데이터를 읽는 현상
- Non-Repeatable Read: 한 트랜잭션 내에서 같은 행을 2번 읽었을 때, 그 사이에 다른 트랜잭션이 해당 데이터를 변경하여 처음과 다른 값을 읽는 현상
Phantom Read: 한 트랜잭션에서 같은 조회 쿼리를 2번 이상 실행했을 떄, 결과의 행수가 달라지는 현상
- Lost-update
```

- DBMS의 동시성 제어는 크게 2가지로 구분 가능
  - 비관적 동시성 제어
  - 낙관적 동시성 제어

제어 방식 핵심 아이디어 대표 기술 장점 단점
| 제어 방식 | 핵심 아이디어 | 대표 기술 | 장점 | 단점 |
|-----------|--------------|----------|------|------|
| 비관적 제어 | "충돌은 자주 발생할 것이다." | 잠금 (Locking) | 데이터 일관성을 확실하게 보장. | 잠금으로 인한 경합 및 대기 발생, 성능 저하 가능성, 데드락(교착 상태) 발생 가능. |
| 낙관적 제어 | "충돌은 거의 발생하지 않을 것이다." | MVCC (Multi-Version Concurrency Control) | 잠금을 사용하지 않아 읽기 성능이 높고 동시성 처리량이 좋음. | 쓰기 충돌이 발생하면 롤백 처리 비용이 발생, 복잡한 구현. |

## Lock 이란 ?

- DB에서 잠금은 특정 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션이 해당 데이터를 동시에 변경하지 못하도록 자물쇠를 거는 방식
- Lock은 크게 2가지로 구분 가능
  - 공유 잠금: 여러 트랜잭션이 동시에 데이터를 읽는 것은 허용하지만, 변경은 막음
  - 베타적 잠금: 오직 하나의 트랜잭션만 데이터에 점근가능.

## MVCC란 ?

- 다중 동시 제어의 약자 (Multi-Version Concurrency Control)
- 트랜잭션 진행 중 데이터가 변경될 떄 마다 바로 변경 사항을 덮어쓴느 대신, 데이터의 새로운 버전을 만드는 방식. 각 트랜잭션은 자신이 시작된 시점을 기준으로 특정 버전의 데이터를 읽게됨.

## MySQL에서의 동시성 제어

MySQL의 컴포넌트로 스토리지 엔진이 있고, 스토리지 엔진에는 여럭 종류가 있는데 각 스토리지엔진에서의 동시성 제어 기법이 사뭇 다름. 해당 글에서는 InnoDB 스토리지 엔진에 대해서만 다룸

## MySQL InnoDB의 락

- InnoDB는 실제 데이터 행 자체에 잠금을 거는 것이 아니라, 해당 행을 가리키는 인덱스 레코드에 잠금을 걸음
  - InnoDB 테이블은 테이블과 인덱스가 일체형으로 되어있기 때문
  - InnoDB 테이블의 클러스터드 인덱스는 리프 노드에서 실제 레코드를 갖음
- InnoDB에서 인덱스는 크게 2가지로 (클러스터드 인덱스 / 논-클러스터드 인덱스) 어떤 인덱스키를 사용하는지에 따라 내부 동작이 달라짐
  - 프라이머리키로 잠글떄
    1. InnoDB는 B-Tree 구조의 PK 인덱스에서 해당 레코드를 찾아 곧바로 잠금
  - 세컨더리 인덱스 키로 잠글 떄
    1. 세컨더리 인덱스에서 해당 인덱스 레코드를 잠금
    2. 세컨더리 인덱스 레코드에 저장된 프라이머리 키 값을 이용해, 클러스터형 인덱스를 찾아가 해당 PK 인덱스 레코드에 추가적인 잠금을 생성

### 레코드 락

- 인덱스의 개별 레코드를 잠금
- 인덱스를 사용할 수 있는 칼럼에 대해서 해당 조건을 만족하는 레코드에 잠긴다.
  ex. index(first_name)이 있을 때, update employees set hire_date = now() where first_name = "chloe" and last_name = "kwon" 에서 first_name = "chloe"에 해당하는 레코드들은 전부 락이 걸린다.
- 인덱스가 하나도 없다면 풀스캔하면서 모든 레코드를 잠근다.

### 갭락

- `REPEATABLE READ` 격리 수준에서 팬텀 리드를 방지하기 위해 존재
- 레코드와 바로 인접한 레코드 사이의 간격을 잠금
- 특정 구간에 갭락을 생성함으로써 새로운 데이터가 `INSERT`되는 것을 막음

```
A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other
```

한 트랜잭션이 획득한 갭락은 다른 트랜잭션 중복되는 범위에 갭락을 생성하는 것을 막지않음. 베타적 갭락일지라도.

### 넥스트 키 락

- Record lock과 Gap lock을 합쳐놓은 형태의 잠금

  \*\* MySQL에서 단순 조회는 락을 생성하지 않음 (MVCC 덕분)

  ```트랜잭션 A
  UPDATE member SET NAME = '123' WHERE age > 10 AND age < 20;
  ```

  - age의 인덱스의 10과 20사이의 간격 (10, 20)에 갭락을 생성
  - age 컬럼에 대한 인덱스가 없다면?
    - MySQL 옵티마이저는 테이블 풀 스캔을 하게 됨
    - 그리고 이때, 전체 테이블에 대해 베타적 갭락을 생성하게 됨

### 인서트 인텐트 락 (갭락의 한 유형)

- 행이 삽입되기 전에 INSERT 작업에 의해 설정되는 갭락의 한 유형
- 갭락은 다른 갭락을 생성하는 것을 막지는 않지만 인서트 인텐트 락이 생성되는 것은 막음
  - 갭락으로 인해서 인서트를 방지하는 원리

## MySQL MVCC

- MVCC는 하나의 데이터에 대해 여러 버전을 관리한다는 의미이고 이를 위해 스냅샷 (READ_VIEW)을 활용
- 데이터베이스에서 '잠금(Lock)'을 사용하지 않고도, 여러 트랜잭션이 동시에 실행될 때 데이터의 일관성을 보장하는 기술
- 읽기 작업과 쓰기 작업이 서로를 차단하지 않아 높은 동시성을 얻을 수 있음
- 핵심 컴포넌트로 언두로그와 리드뷰를 알아야함

### 언두로그

- 데이터가 변경되기 이전 버전의 데이터를 별도의 공간에 백업해두는 곳
- UPDATE나 DELETE 쿼리가 실행되면, InnoDB는 새로운 데이터로 덮어쓰기 전에 기존 데이터를 언두 로그에 먼저 기록

### 리드뷰

- 트랜잭션이 처음으로 읽기(SELECT) 작업을 시작할 때, 현재 데이터베이스의 상태를 사진 찍듯이 기록한 정보 객체
  - 현재 시점에 활성 상태인(아직 커밋되지 않은) 다른 트랜잭션들의 ID 목록 포함
- 트랜잭션은 데이터를 읽을 떄, 무조건 최신 데이터를 보는 것이 아니라 리드뷰를 근거로 자신에게 보여야할 최신 데이터가 무엇인지 판단
