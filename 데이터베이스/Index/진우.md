## 1. Index란 무엇인가?

<img width="1320" height="737" alt="image" src="https://github.com/user-attachments/assets/5457a8ef-e590-46ee-b1d7-66c7614c70fc" />


- 데이터베이스의 검색 속도를 향상시키기 위한 자료구조(?)이다.
    - `index 테이블`을 먼저 탐색하고, 해당 값을 이용하여 실제 데이터가 저장된 `테이블`을 탐색하는 것
- 대신, 약 10%의 추가 저장공간과 쓰기 작업(?)을 필요로 한다.
- 인덱스는 특정 “컬럼”에 적용을 하는 것!

```sql
CREATE INDEX idx_user_email
ON user(created_at);
-- created_at이라는 컬럼에 인덱스를 만든 것이다!
```

## 2. Full-scan vs Index-scan

- index가 걸려있는 컬럼을 이용하여 조회를 할때, 이것을 `Index-scan` 이라고 한다. 수백배 이상 빨리질 수 있다.
- index가 없는 컬럼을 이용한다면, 모든 테이블을 조회한다. O(N)… 이것을 `Full table scan` 이라고 한다.

## 3. Index-scan시 주의사항

- SELECT 과정에서 `Index-scan`을 사용하려면, **where절의 조건에 index가 걸린 컬럼을 사용하면 된다.**
- 다만, 해당 컬럼을 가공하면 `index-scan`을 타지 못하고 `full table scan`이 된다!!

```sql
-- 인덱스를 타는 쿼리1
SELECT * FROM orders
WHERE SYSDATE < created_at 
                    
-- 인덱스를 타는 쿼리2
SELECT * FROM orders
WHERE created_at BETWEEN TO_DATE('2024-08-02', 'YYYY-MM-DD')
                    AND TO_DATE('2024-08-02 23:59:59', 'YYYY-MM-DD HH24:MI:SS');

-- 인덱스를 타지 않는 쿼리
SELECT * FROM orders
WHERE TO_CHAR(created_at, 'YYYY-MM-DD') = '2024-08-02';

```

- 내가 작성한 쿼리가 `index-scan` 을 타는지, `full table scan`을 타는지 궁금하면? → **쿼리실행계획**을 확인하기!!

## 4. index의 자료구조

- index는 자료구조로 `B+Tree`를 사용한다.
- 각 노드에는 [key, rowID]가 들어있다고 생각하면 된다.

### 4.1. B-Tree

- **B-Tree는, 하나의 노드가 가질 수 있는 자식 노드가 2개 이상인 트리구조를 의미한다.**
- Balanced-Tree이다. 항상 정렬된 상태로 값을 저장한다. → 삽입과 조회의 시간복잡도는 O(log N)

<img width="2080" height="538" alt="image" src="https://github.com/user-attachments/assets/9b4ab811-2812-45e3-9b3c-1591d8b5ef2a" />


- 자식노드가 3개라면,  그 노드에는 2개의 값이 저장이 되어야 한다. 그래야 분기가 되니까.
- 조회 시간이 O(log N)인데 왜 쓰지 않을까?? → DB는 `=` 검색 뿐 아니라 범위검색(`<`, `>`)도 매우 자주 일어나기 때문!!
- 범위 검색에는 비효율적이다.
- (중요)리프노드에 **[key,** rowID**]** 가 들어있다. 따라서 우리는 인덱스 탐색을 통해 해당 row에접근을 할 수 있는 것!

### 4.2. B+Tree

- B+Tree는 B-Tree에서 범위검색의 단점을 해결한 자료구조이다.
- **리프노드를 제외한 노드에는 값을 저장하지 않는다. 또한 리프노드끼리 포인터가 연결되어 있다.**
- 따라서 범위 검색에 유리하다.

<img width="1580" height="1127" alt="image" src="https://github.com/user-attachments/assets/1da54b00-c17d-468b-bdb7-c91a0896d764" />


### 

## 5. index의 특징

### 5.1. 추가 작업

- `insert` 작업은 해당 row에 대해 새로운 인덱스를 추가해야 하고, 인덱스(트리)를 다시 정렬하는 과정이 필요하다.
- `delete` 작업은 해당 인덱스에 대해 **사용안함**처리를 한다. 삭제가 아님!
- `update` 작업은 `delete + update` 이다.

- 따라서 insert, delete, update가 잦은 테이블에 `index` 를 생성하는건 오히려 역효과를 가져올수도…

### 5.2. 중복 값이 낮은 컬럼(cardinality 가 높은 컬럼)

- 인덱스는 `[key, rowID]` 형태로 노드에 저장한다. 따라서 `key`가 중복이 되면 성능이 떨어지겠찌?

→ 따라서, 조회가 잦고, CUD작업이 없고, 중복이 아닌 컬럼에 거는게 제일 효율적이다 !!

## 6. 클러스터 인덱스 vs 논클러스터 인덱스

### 6.1. 클러스터 인덱스

- 리프노드에 rowID가 아니라, **실제 데이터**가 들어있는 인덱스를 말함
    - Inno DB에서 테이블 row = 클러스터 인덱스 리프 노드
- 따라서, 테이블당 1개이다.
- PK로 설정된 컬럼을 이용하여 DB엔진이 알아서 생성하고, 없다면 Unique컬럼, 없다면 임의로 만듦.
- 데이터가 덩어리(클러스)져서 정렬되어 있으며, 범위검색하기 딱 조아!!

<img width="713" height="660" alt="image" src="https://github.com/user-attachments/assets/9d8f2e72-4c04-43ce-93ee-0d8c9f845c19" />


### 6.2. 논클러스터 인덱스(보조 인덱스, 일반 인덱스..)

- 기본으로 만드는 pk인덱스가 아니라, 사용자가 만드는 모든 인덱스이다.
- 리프 노드에는 [key, rowID]가 들어있다.
    - 그래서, 여기서 얻은 rowID를 가지고 다시한번 탐색을 해야하므로 클러스터 인덱스를 한번 더 타는 것!!!!
- 테이블당 64개까지 가능
- 클러스터 인덱스와 다르게 정렬되지 않음

<img width="801" height="717" alt="image" src="https://github.com/user-attachments/assets/5f897074-cd66-46b0-9e05-0ea6b8214a1e" />

