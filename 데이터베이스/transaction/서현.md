## **트랜잭션(Transaction)이란?**
---
> 데이터베이스에서 **한 번에 수행되어야 할 작업의 논리적인 단위**

: 하나 또는 여러 개의 데이터베이스 연산(삽입, 수정, 삭제, 읽기 등)이 하나의 트랜잭션 안에서 실행됨
→ 데이터베이스의 **일관성과 동시성 제어**에서 핵심이 되는 개념

Ex. 은행 송금: A 계좌 출금 + B 계좌 입금
```sql
BEGIN;              -- 트랜잭션 시작 / 혹은 START TRANSACTION;
/* 대부분의 RDBMS에서는 autocommit이 기본으로 설정돼 있어 명시적으로 BEGIN 하지 않으면 각 쿼리가 자동 커밋됨 */

-- A 계좌에서 50,000원 출금
UPDATE accounts SET balance = balance - 50000 WHERE acc_id = 'A';

-- B 계좌로 50,000원 입금
UPDATE accounts SET balance = balance + 50000 WHERE acc_id = 'B';

COMMIT;             -- 성공 시 영구 반영
-- 혹은 ROLLBACK;   -- 실패 시 이전 상태로 되돌림
```

### **트랜잭션의 4가지 속성 [ACID]**
---
| **속성** | **설명** |
| --- | --- |
| **Atomicity (원자성)** | 모든 작업이 **전부 수행되거나 전혀 수행되지 않아야** 함 |
| **Consistency (일관성)** | 트랜잭션 **전후의 데이터 무결성이 보장**되어야 함 |
| **Isolation (격리성)** | **동시**에 수행되는 트랜잭션이 **서로 간섭하지 않아야** 함 |
| **Durability (지속성)** | 트랜잭션 완료 후 **결과는 영구적으로 반영**되어야 함 |

### 트랜잭션의 상태 변화
---
| 상태 | **설명** |
| --- | --- |
| **Active** | 트랜잭션 실행 중 |
| **Partially Committed** | 커밋 직전 상태 |
| **Committed** | 트랜잭션이 성공적으로 종료됨 |
| **Failed** | 수행 중 오류 발생 |
| **Terminated** | 종료 상태 |
| **Aborted** | Abort, Rollback 수행 이후 |


## **격리 수준(Isolation Level)이란?**
---
> 여러 트랜잭션이 동시에 수행될 때 발생하는 **동시성 문제를 어떻게 처리할 것인가**를 결정하는 기준

### **동시성 문제**
---
- `Dirty Read`
    : 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽음
- `Non-repeatable Read`
    : 한 트랜잭션 내에서 같은 데이터를 읽는 때마다 값이 달라짐
- `Phantom Read`
    : 동일 조건으로 여러 번 조회 시 그 사이에 삽입/삭제된 데이터가 나타나 결과가 달라짐

### **격리 수준의 4단계 (SQL 표준)**
---
| **격리 수준** | **설명** | **발생 가능한 동시성 문제** |
| --- | --- | --- |
| **READ UNCOMMITTED** | 가장 낮은 수준.
커밋되지 않은 데이터도 읽을 수 있음 | Dirty, Non-repeatable, Phantom |
| **READ COMMITTED** | 커밋된 데이터만 읽음.
대부분의 DB의 기본값 | Non-repeatable, Phantom |
| **REPEATABLE READ** | 같은 값 동일하게 반복 읽기 보장.
MySQL의 InnoDB 기본값 | Phantom |
| **SERIALIZABLE** | 가장 높은 수준.
트랜잭션이 순차적으로 실행된 것처럼 보임 | - |

- 격리 수준이 높을수록 데이터 일관성을 보장하지만, 성능이 저하될 수 있음
    → 서비스 특성에 따라 적절한 수준을 선택해야 함
    - 대량 데이터 조회/분석 용도 → 낮은 격리 수준
        - Ex. 게시판/쇼핑몰 → READ COMMITTED
    - 금융/정합성이 중요한 환경 → 높은 격리 수준
        - Ex. 은행 시스템 → SERIALIZABLE
            ( 락 경합 또는 데드락 이슈로 주의 요망 )
            
            - 락 경합
                - 여러 트랜잭션 또는 세션이 동시에 동일한 데이터(혹은 리소스)에 락(Lock)을 걸거나 변경하려고 할 때 발생
                - Ex. 여러 사용자가 같은 레코드나 테이블을 동시에 수정하거나, Unique 인덱스가 설정된 필드에 동시에 같은 값을 삽입하려고 할 때 누구 하나가 락을 가진 동안 나머지가 대기
                - 반복적으로 발생하면 시스템의 처리 속도가 저하되고 대기 시간이 길어짐
            - 데드락 이슈
                - 두 개 이상의 트랜잭션이 서로 서로가 점유한 락의 해제를 기다리며 무한정 대기하게 되는 상태
                - Ex. 트랜잭션 A는 레코드 1을 락, 레코드 2를 추가로 락 걸려고 대기 + 트랜잭션 B는 반대로 이미 레코드 2를 락 걸고, 레코드 1을 락 걸려고 대기
                - 서로가 서로를 기다려 작업이 영원히 끝나지 않음
- Ex.
    ```sql
    -- 트랜잭션 내에서 격리 수준 지정
    BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    
    SELECT * FROM products WHERE id = 1;
    
    -- 중간에 다른 트랜잭션에서 값을 바꿔도 이 트랜잭션에서는 이전 값이 유지됨
    
    COMMIT;
    
    /* PostgreSQL 기준 */
    ```
    + `MySQL`의 경우 세션 단위 설정도 가능
    ```
    SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    ```

- **DBMS별 기본 격리 수준**
    - `READ COMMITTED`
        - PostgreSQL, Oracle, SQL Server
    - `REPEATABLE READ`
        - MySQL (InnoDB)
