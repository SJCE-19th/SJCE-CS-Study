# 트랜잭션(Transaction)

## 1. 트랜잭션이란?

`트랜잭션(Transaction)`은 하나의 작업 단위다.

ex)

- A가 결제를 하며 계좌에서 100원을 뺌
- 동시에 상품 재고를 1 줄이는 작업이 있다고 가정

이 두 작업이 중간에 하나라도 실패하면?
-> 계좌는 빠졌는데 상품은 그대로거나, 반대의 상황이 생길 수 있다.

그래서 두 작업을 한 묶음(=트랜잭션)으로 묶어서,
모두 성공하면 커밋(Commit), 중간에 하나라도 실패하면 롤백(Rollback) 해야한다.

트랜잭션은 여러 작업을 하나의 논리적 단위로 묶은 것이고,
그 중 하나라도 실패하면 전체를 없었던 일로 되돌려야 `데이터 정합성`을 유지할 수 있다. 이게 바로 트랜잭션의 핵심이다.

## 2. 트랜잭션의 4가지 속성 - ACID

| 속성                | 의미                                                       | 예시                                                                   |
| ------------------- | ---------------------------------------------------------- | ---------------------------------------------------------------------- |
| Atomicity(원자성)   | 전부 성공하거나 전부 실패해야 한다                         | 계좌에서 돈 빼고 상품 수량 줄이기 -> 둘 중 하나라도 실패하면 모두 롤백 |
| Consistency(일관성) | 트랜잭션 전후로 DB 상태는 항상 유효한 상태여야 한다        | 제약조건(ex: 잔액이 음수면 안됨)을 깬 상태로 끝나면 안 됨              |
| Isolation(격리성)   | 동시에 여러 트랜잭션이 실행될 때 서로 간섭하지 않아야 한다 | 두 사용자가 동시에 주문해도 재고 계산이 꼬이지 않아야 한다             |
| Durability(지속성)  | 커밋된 내용은 시스템 장애가 나도 보존이 되어야 한다        | 전원이 꺼져도 디스크에 반영된 커밋 내용은 남아 있어야 한다             |

## 3. Isolation Level(격리 수준)

여러 트랜잭션이 동시에 실행될 때, 서로 간섭하지 않도록 하는 정도를 설정하는 것.

- 격리 수준이 높을수록 -> 안전하지만, 성능 저하(락, 대기 시간)
- 격리 수준이 낮을수록 -> 정합성 문제 위험

### 3.1 격리 수준으로 인해 생기는 문제들

| 문제                | 설명                                                    | 예시                                                                             |
| ------------------- | ------------------------------------------------------- | -------------------------------------------------------------------------------- |
| Dirty Read          | 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽음        | A가 잔액을 -100으로 만들었다가 롤백했는데, B가 그 -100을 읽음                    |
| Non-repeatable Read | 같은 데이터를 두 번 읽었는데 값이 달라짐                | A가 상품 재고를 읽고 처리하는 중, B가 그걸 변경해서 A가 다시 읽었을 때 값이 다름 |
| Phantom Read        | 조건에 맞는 행이 중간에 추가/삭제 되어 조회 결과가 바뀜 | A가 "카테고리 A 상품 수"를 조회했는데, B가 상품을 추가함                         |

### 3.2 ANSI SQL 표준 격리 수준 4단계

| 수준             | Dirty Read | Non-repeatable Read | Phantom Read | 설명                                       |
| ---------------- | ---------- | ------------------- | ------------ | ------------------------------------------ |
| READ UNCOMMITTED | ✅         | ✅                  | ✅           | 거의 격리가 없음. 읽기만 빠름              |
| READ COMMITTED   | ❌         | ✅                  | ✅           | 커밋된 데이터만 읽음                       |
| REPEATABLE READ  | ❌         | ❌                  | ✅           | 읽은 행은 트랜잭션 내에서 고정됨           |
| SERIALIZABLE     | ❌         | ❌                  | ❌           | 가장 엄격. 트랜잭션을 직렬화한 것처럼 동작 |

## 4. 트랜잭션 구현 방식

### 4.1 트랜잭션과 격리 수준의 구현

대다수의 DB는 아래 3가지 요소를 조합해서 트랜잭션을 구현한다.

1. **락(Lock)**

   - 특정 데이터(Row or Table)에 대해 동시에 접근하지 못하도록 제어
   - 종류:
     - 공유 락(S Lock): 읽기는 여러 트랜잭션이 가능하지만, 쓰기는 불가
     - 배타 락(X Lock): 다른 트랜잭션은 읽기/쓰기가 모두 불가

2. **MVCC(Multi Version Concurrency Control, 다중 버전 동시성 제어)**

   - 데이터를 변경할 때, 기존 데이터를 즉시 덮어쓰지 않고 버전을 추가함
   - 각 트랜잭션은 자기 시점의 데이터 Snapshot을 보고 작업
   - 덕분에 읽기 작업은 락을 거의 사용하지 않고도 동시에 가능함

3. **Undo/Redo 로그(WAL)**
   - 트랜잭션이 수행한 모든 변경 사항을 로그에 기록해 복구 가능하게 함
   - Atomicity와 Durability를 보장

## 5. PostgreSQL의 트랜잭션 동작 원리

### 5.1 PostgreSQL의 격리 수준 구현 방식

| 격리 수준        | 구현 방식                                                     |
| ---------------- | ------------------------------------------------------------- |
| Read Uncommitted | PostgreSQL은 이 모드를 지원하지 않음                          |
| Read Committed   | Snapshot은 각 쿼리 실행 시점마다 갱신됨                       |
| Repeatable Read  | 트랜잭션 시작 시점의 Snapshot을 고정해서 사용                 |
| Serializable     | 내부적으로 SSI(Serializable Snapshot Isolation) 알고리즘 사용 |

### 5.2 PostgreSQL의 기본 격리 수준: Read Committed

왜 이걸 기본으로 사용할까?

**장점:**

- 성능이 좋음
  - snapshot을 쿼리마다 새로 만들기 때문에 롱런 트랜잭션과 간섭이 적음
- 락을 거의 안 걸기 때문에 병렬 처리에 유리함
  - 읽기 -> 락 없이 snapshot 기반
  - 쓰기 -> 필요한 Row만 Lock

**단점:**

- 읽은 데이터를 믿고 후속 처리를 하면 위험
  - 재고 확인 후 주문 생성
  - 중복 확인 후 INSERT
  - 특정 조건으로 SELECT -> 그 값을 UPDATE

### 5.3 PostgreSQL의 트랜잭션 실행 구조

1. **트랜잭션 시작 -> BEGIN**
   PostgreSQL은 이 시점에 트랜잭션을 위한 `Transaction ID(XID)`를 할당한다.

2. **쿼리 실행**

   - 읽기 시: Snapshot을 기준으로 MVCC 버전 검사
   - 쓰기 시: Table/Row에 적절한 Lock 설정, 새로운 버전 생성

3. **커밋(Commit)**

   - WAL(Write-Ahead Log)에 변경 내용 기록
   - `pg_clog`에 트랜잭션 완료 상태 기록 -> Durable 보장
   - dead tuple은 살아있지만 visible하지 않음(Vacuum 대상)

4. **롤백(Rollback)**
   - 변경 사항 적용 X
   - undo가 아닌 MVCC로, 다른 트랜잭션이 읽지 못하게만 함

### 5.4 스냅샷(Snapshot)이란?

스냅샷은 이 트랜잭션이 볼 수 있는 트랜잭션 ID들의 목록이다.
즉, PostgreSQL은 트랜잭션이 시작되었을 때 누가 아직 살아있고, 누가 끝났는지를 기준으로 어떤 row가 보여야 하는지를 결정한다.

스냅샷이 생성되는 시점은 격리 수준에 따라 다르다.

| 격리 수준       | 스냅샷 생성 시점           | 설명                                           |
| --------------- | -------------------------- | ---------------------------------------------- |
| Read Committed  | 쿼리 실행 시마다           | SELECT를 실행할 때마다 최신 커밋된 데이터 기준 |
| Repeatable Read | 트랜잭션 시작 시 한 번     | 트랜잭션 전체에서 같은 스냅샷을 유지           |
| Serializable    | Repeatable Read + SSI 감시 | 논리적 충돌을 감지하기 위한 추가 정보 포함     |

**예시 1. Read Committed: 쿼리마다 다른 snapshot 사용**

```sql
BEGIN;

SELECT * FROM accounts WHERE id = 1; -- snapshot #1 (balance: 100)

-- 다른 트랜잭션에서 balance = 200으로 변경 후 커밋

SELECT * FROM accounts WHERE id = 1; -- snapshot #2 (balance: 200)

COMMIT;
```

쿼리 실행마다 snapshot이 새로 만들어지기 때문에, Non-repeatable Read가 발생한다.

**예시 2. Repeatable Read: 트랜잭션 전체에서 snapshot이 고정됨**

```sql
BEGIN;

SELECT * FROM accounts WHERE id = 1; -- snapshot #1 (balance: 100)

-- 다른 트랜잭션에서 balance = 200으로 변경 후 커밋

SELECT * FROM accounts WHERE id = 1; -- 여전히 snapshot #1 (balance: 100)

COMMIT;
```

### 5.5 Dead Tuple과 Vacuum

**dead tuple이란?**
PostgreSQL에서는 데이터를 수정하거나 삭제할 때, 기존 데이터를 즉시 지우지 않고 새 버전을 추가한다.

```sql
-- 원래 있던 데이터
id = 1, balance = 1000  → (xmin=100, xmax=null)

-- balance를 900으로 업데이트하면?
→ balance = 900 (xmin=102, xmax=null)
→ 기존 balance = 1000 (xmin=100, xmax=102) → 이건 "dead tuple"
```

- `xmin`: 이 튜플을 만든 트랜잭션 ID
- `xmax`: 이 튜플을 삭제/수정한 트랜잭션 ID(없으면 살아 있음)

어떤 튜플이 보여질지 결정할 때 PostgreSQL은 다음 기준을 본다.

```sql
xmin <= 현재 트랜잭션의 snapshot에 포함 &&
(xmax is null OR xmax > 현재 트랜잭션)
```

**Vacuum**
PostgreSQL은 Vacuum이라는 작업을 통해 더 이상 누구에게도 보이지 않는 튜플을 찾아 물리적으로 제거하거나 마킹해서 공간을 재활용한다.

### 5.6 SSI(Serializable Snapshot Isolation)란?

PostgreSQL의 Serializable 격리 수준은 락 기반이 아니라, SSI 알고리즘으로 동작한다.

기본 원리는 Repeatable Read와 같이 Snapshot 기반으로 읽는다.
하지만 트랜잭션 간 잠재적인 충돌(Conflict)을 감지해서 충돌이 확정되면 트랜잭션 중 하나를 강제로 롤백시킨다.

1. 각 트랜잭션의 읽기/쓰기 범위를 추적
2. 어떤 트랜잭션이 나중에 커밋될 경우, 다른 트랜잭션에 영향을 주는지 검사
3. 위험한 충돌을 탐지하면 `could not serialize access due to read/write dependencies` 오류 발생

```text
T1: SELECT 재고 FROM 상품 WHERE id = 1;
T2: SELECT 재고 FROM 상품 WHERE id = 1;

(둘 다 '재고=10'을 보고, 각자 '5개 판매'를 적용)

T1: UPDATE 상품 SET 재고 = 5; -- 커밋
T2: UPDATE 상품 SET 재고 = 5; -- 커밋 시점에 충돌 감지 → 롤백
```

## 6. PostgreSQL에서 동시성 문제를 해결하는 3가지 전략

### 6.1 비관적 락 (FOR UPDATE)

```sql
  BEGIN;
  SELECT * FROM products WHERE id = 1 FOR UPDATE;
  -- 이 시점부터 다른 트랜잭션은 이 행에 접근 불가
  UPDATE products SET stock = stock - 5;
  COMMIT;
```

-> 이 행은 트랜잭션이 끝날 때까지 다른 트랜잭션이 읽거나 수정할 수 없음

### 6.2 낙관적 락 (버전 체크)

```sql
UPDATE products SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 42;
```

-> 만약 다른 트랜잭션이 먼저 version을 올렸다면 이 쿼리는 0건을 수정하고 실패

### 6.3 트랜잭션 격리 수준을 높인다

격리 수준을 Repeatable Read나 Serializable로 높여서 사용

- 장점: 고정된 스냅샷이 필요한 읽기 기반 집계 작업에 유용
- 단점: 트랜잭션 충돌이 나면 롤백됨 -> 복잡한 retry 로직 필요
